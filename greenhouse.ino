// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//IMPORTANT: change packet size in PubSub.h to 200

#include <Wire.h>
#include <Adafruit_BMP085.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <DHT.h>;
#include <WiFiEspClient.h>
#include <WiFiEsp.h>
#include <WiFiEspUdp.h>
#include <PubSubClient.h>
#include "SoftwareSerial.h"

#define NETWORK //compile without network for testing

// Configuration
#define THINGS_TITLE "Greenhouse Sensors"
#define WIFI_AP "<SSID>"
#define WIFI_PASSWORD "<KEY>"
#define TOKEN "<API KEY>"
char thingsboardServer[] = "<SERVER IP>";

#define INTERVAL 300000
#define ONE_WIRE_BUS 6
#define DHTPIN 7
#define DHTTYPE DHT22   // DHT 22  (AM2302)
#define echoPin 2 // SR04 Echo Pin
#define trigPin 4 // SR04 Trigger Pin
#define LEDPin 13 // SR04 Onboard LED
#define RX 3 //ESP RX
#define TX 5 //ESP TX
#define BUFFER_SIZE 100

// Setup a oneWire instance to communicate with any OneWire devices
// (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);
// Pass our oneWire reference to Dallas Temperature.
DallasTemperature sensors(&oneWire);

Adafruit_BMP085 bmp;
DHT dht(DHTPIN, DHTTYPE);

// Initialize the Ethernet client object
WiFiEspClient espClient;
PubSubClient client(espClient);
SoftwareSerial soft(RX, TX);

int status = WL_IDLE_STATUS;
unsigned long lastSend;

void setup() {
#ifndef NETWORK
  Serial.begin(9600);
#endif

  //start BMP180
  if (!bmp.begin()) {
    while (1) {}
  }

  // Start DS
  sensors.begin();
  dht.begin();

  //HC-SR04 Ping distance sensor
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);

  //setup wifi
#ifdef NETWORK
  InitWiFi();
  client.setServer( thingsboardServer, 1883 );
  lastSend = 0;
#endif
}

unsigned long time_  = 0;

void loop() {

  if ( time_ > 0 && millis() < time_ )
  {return;}

  time_ = millis() + ( INTERVAL );

  sensors.requestTemperatures(); // Send the command to get temperatures

  char attributes[BUFFER_SIZE];
  int position = 0;

  float _bmp_temp = bmp.readTemperature();
  float _dht_temp = dht.readTemperature();
  float _dht_humidity = dht.readHumidity();
  int32_t _bmp_pressure = bmp.readPressure();
  //  float _bmp_altitude = bmp.readAltitude();
  //  int32_t  _bmp_sealevel_pressure = bmp.readSealevelPressure();
  //  float _bmp_real_altitude = bmp.readAltitude(101500);
  float _ds_temperature = sensors.getTempCByIndex(0);

  //    const char* _template = "{\"T2\":%d.%02d, \"T1\":%d.%02d, \"f\":%d.%02d, \"atm\":%lu, \"atma\":%d.%02d, \"atmps\":%lu, \"atmsr\":%d.%02d, \"Tw\":%d.%02d, \"h\":%d}";
  const char* _template = "{\"T2\":%d.%02d, \"T1\":%d.%02d, \"f\":%d.%02d, \"atm\":%lu, \"Tw\":%d.%02d, \"h\":%d}";
  int _length = snprintf ( attributes, BUFFER_SIZE, _template,
                           (int)_bmp_temp, (int)(_bmp_temp * 100.0) % 100,
                           (int)_dht_temp, (int)(_dht_temp * 100.0) % 100,
                           (int)_dht_humidity, (int)(_dht_humidity * 100.0) % 100,
                           (unsigned long)_bmp_pressure,
                           //                            (int)_bmp_altitude, (int)(_bmp_altitude * 100.0) % 100,
                           //                            _bmp_sealevel_pressure,
                           //                            (int)_bmp_real_altitude, (int)(_bmp_real_altitude * 100.0) % 100,
                           (int)_ds_temperature, (int)(_ds_temperature * 100.0) % 100,
                           get_distance() );

  if ( _length > BUFFER_SIZE ) {
    sprintf( attributes, "{\"error\":\"message to long\"}" );
  }

  //  payload.toCharArray( attributes, BUFFER_SIZE );

#ifndef NETWORK
  Serial.print("(");
  Serial.print(strlen(attributes));
  Serial.print(")");
  Serial.print(attributes);
  Serial.println();
  Serial.println("---");
#endif

#ifdef NETWORK
  status = WiFi.status();
  if ( status != WL_CONNECTED) {
    while ( status != WL_CONNECTED) {
      // Connect to WPA/WPA2 network
      status = WiFi.begin(WIFI_AP, WIFI_PASSWORD);
      delay(500);
    }
  }

  if ( !client.connected() ) {
    reconnect();
  }

  client.publish( "v1/devices/me/telemetry", attributes );
#endif
}

long get_distance() {

  //Variables for SR04T
  int maximumRange = 200; // Maximum range needed
  int minimumRange = 0; // Minimum range needed
  long duration, distance = 0; // Duration used to calculate distance
  int count = 0;

  while ( distance == 0 && count < 10 ) {
    /* The following trigPin/echoPin cycle is used to determine the
      distance of the nearest object by bouncing soundwaves off of it. */
    digitalWrite(trigPin, LOW);
    delayMicroseconds(2);

    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10);

    digitalWrite(trigPin, LOW);
    duration = pulseIn(echoPin, HIGH);

    //Calculate the distance (in cm) based on the speed of sound.
    distance = duration / 58.2;

    if (distance >= maximumRange || distance <= minimumRange) {

#ifndef NETWORK
      Serial.print("wrong distance:"); Serial.println(distance);
#endif

      distance = 0;
      /* Send a negative number to computer and Turn LED ON
        to indicate "out of range" */
      digitalWrite(LEDPin, HIGH);
      count++;
      delay(200);

    } else {
      /* Send the distance to the computer using Serial protocol, and
        turn LED OFF to indicate successful reading. */
      digitalWrite(LEDPin, LOW);
    }
  }
  return distance;
}

void InitWiFi() {
  // initialize serial for ESP module
  soft.begin(9600);
  // initialize ESP module
  WiFi.init(&soft);
  // check for the presence of the shield
  if (WiFi.status() == WL_NO_SHIELD) {
    // don't continue
    while (true);
  }

  // attempt to connect to WiFi network
  while ( status != WL_CONNECTED) {
    // Connect to WPA/WPA2 network
    status = WiFi.begin(WIFI_AP, WIFI_PASSWORD);
    delay(500);
  }
}

void reconnect() {
  // Loop until we're reconnected
  while (!client.connected()) {
    // Attempt to connect (clientId, username, password)
    if ( !client.connect(THINGS_TITLE, TOKEN, NULL) ) {
      // Wait 5 seconds before retrying
      delay( 1 );
    }
  }
}
